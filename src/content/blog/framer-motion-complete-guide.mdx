---
title: "Framer Motion 完全指南：React 动画的终极解决方案"
excerpt: "深入探索 Framer Motion 的强大功能，从基础动画到高级交互，打造流畅、专业的 React 应用动效"
date: "2024-05-27"
tags:
  - React
  - Framer Motion
  - 动画
  - 前端开发
---

# Framer Motion 完全指南：React 动画的终极解决方案

在现代 Web 应用中，精心设计的动画不仅能提升用户体验，还能传达信息、引导用户注意力，甚至塑造品牌形象。对于 React 开发者来说，Framer Motion 是一个强大而灵活的动画库，它提供了声明式的 API 和丰富的功能，让复杂的动画变得简单易用。

本文将全面介绍 Framer Motion 的各个方面，从基础概念到高级技巧，帮助你掌握这一强大的动画工具。

## Framer Motion 简介

Framer Motion 是一个为 React 设计的生产级动画库，由 Framer 团队开发。它提供了一套简洁的声明式 API，让你可以轻松创建各种动画效果，从简单的过渡到复杂的手势交互。

### 主要特点

- **声明式 API**：使用简单的 props 定义动画
- **手势支持**：内置拖拽、平移、点击等手势
- **布局动画**：自动为布局变化添加动画
- **变体系统**：定义和复用动画状态
- **动画编排**：控制动画序列和时间线
- **SVG 动画**：专门的 SVG 路径动画支持
- **可访问性**：尊重用户的减少动画设置
- **性能优化**：使用 GPU 加速和智能默认值

## 安装与基本设置

### 安装

使用 npm、yarn 或 pnpm 安装 Framer Motion：

```bash
# 使用 npm
npm install framer-motion

# 使用 yarn
yarn add framer-motion

# 使用 pnpm
pnpm add framer-motion
```

### 基本导入

```jsx
import { motion } from "framer-motion";
```

## 基础动画

Framer Motion 的核心是 `motion` 组件，它是对标准 HTML 和 SVG 元素的包装，添加了动画功能。

### 简单动画

最基本的动画可以通过 `animate` 属性定义：

```jsx
import { motion } from "framer-motion";

function FadeIn() {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.5 }}
    >
      这个元素会淡入
    </motion.div>
  );
}
```

### 动画属性

Framer Motion 支持多种动画属性：

```jsx
<motion.div
  initial={{
    opacity: 0,
    scale: 0.8,
    y: 20,
    rotate: -5
  }}
  animate={{
    opacity: 1,
    scale: 1,
    y: 0,
    rotate: 0
  }}
  transition={{
    duration: 0.5,
    ease: "easeOut"
  }}
>
  多属性动画
</motion.div>
```

### 过渡选项

`transition` 属性允许你控制动画的各个方面：

```jsx
<motion.div
  animate={{ x: 100 }}
  transition={{
    duration: 0.5,        // 持续时间
    delay: 0.2,           // 延迟
    ease: "easeInOut",    // 缓动函数
    times: [0, 0.5, 1],   // 关键帧时间点
    repeat: 2,            // 重复次数
    repeatType: "reverse", // 重复类型：loop, reverse, mirror
    repeatDelay: 0.5      // 重复延迟
  }}
>
  自定义过渡
</motion.div>
```

### 常用缓动函数

Framer Motion 提供了多种内置缓动函数：

- `"linear"`：线性
- `"easeIn"`, `"easeOut"`, `"easeInOut"`：标准缓动
- `[0.42, 0, 0.58, 1]`：自定义贝塞尔曲线
- `"circIn"`, `"circOut"`, `"circInOut"`：圆形缓动
- `"backIn"`, `"backOut"`, `"backInOut"`：回弹缓动
- `"anticipate"`：预期缓动

### 弹簧动画

对于更自然的动画，可以使用弹簧物理效果：

```jsx
<motion.div
  animate={{ scale: 1.2 }}
  transition={{
    type: "spring",
    stiffness: 100,   // 刚度
    damping: 10,      // 阻尼
    mass: 1,          // 质量
    velocity: 0       // 初始速度
  }}
>
  弹簧动画
</motion.div>
```

## 手势动画

Framer Motion 提供了丰富的手势支持，让你可以轻松创建交互式动画。

### 悬停动画

```jsx
<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  transition={{ type: "spring", stiffness: 400, damping: 17 }}
  className="bg-blue-500 text-white px-4 py-2 rounded"
>
  悬停我
</motion.button>
```

### 拖拽功能

```jsx
<motion.div
  drag
  dragConstraints={{ left: -100, right: 100, top: -50, bottom: 50 }}
  dragElastic={0.2}
  whileDrag={{ scale: 1.1 }}
  className="w-20 h-20 bg-purple-500 rounded-lg cursor-grab"
>
  拖拽我
</motion.div>
```

### 平移手势

```jsx
<motion.div
  whileTap={{ cursor: "grabbing" }}
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
  className="w-20 h-20 bg-green-500 rounded-lg cursor-grab"
>
  水平拖拽
</motion.div>
```

## 变体系统

变体系统允许你定义命名的动画状态，并在组件之间协调动画。

### 基本变体

```jsx
const variants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0 }
};

function FadeInUp() {
  return (
    <motion.div
      variants={variants}
      initial="hidden"
      animate="visible"
      transition={{ duration: 0.5 }}
    >
      使用变体的动画
    </motion.div>
  );
}
```

### 变体传播

变体会自动传播到子元素：

```jsx
const containerVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      delayChildren: 0.3,
      staggerChildren: 0.2
    }
  }
};

const itemVariants = {
  hidden: { y: 20, opacity: 0 },
  visible: { y: 0, opacity: 1 }
};

function StaggeredList() {
  return (
    <motion.ul
      variants={containerVariants}
      initial="hidden"
      animate="visible"
      className="space-y-2"
    >
      {[1, 2, 3, 4].map(i => (
        <motion.li
          key={i}
          variants={itemVariants}
          className="p-4 bg-gray-100 rounded"
        >
          项目 {i}
        </motion.li>
      ))}
    </motion.ul>
  );
}
```

## 动画控制

### 使用 useAnimation

`useAnimation` 钩子允许你以命令式方式控制动画：

```jsx
import { motion, useAnimation } from "framer-motion";

function AnimationControl() {
  const controls = useAnimation();
  
  function startAnimation() {
    controls.start({
      x: 100,
      transition: { duration: 0.5 }
    });
  }
  
  function resetAnimation() {
    controls.start({ x: 0 });
  }
  
  return (
    <div>
      <motion.div
        animate={controls}
        className="w-20 h-20 bg-blue-500 rounded"
      />
      <button onClick={startAnimation} className="mt-4 mr-2 px-4 py-2 bg-green-500 text-white rounded">
        开始
      </button>
      <button onClick={resetAnimation} className="mt-4 px-4 py-2 bg-red-500 text-white rounded">
        重置
      </button>
    </div>
  );
}
```

### 序列动画

```jsx
async function sequence() {
  await controls.start({ x: 100 });
  await controls.start({ y: 100 });
  await controls.start({ x: 0 });
  return await controls.start({ y: 0 });
}
```

## 布局动画

Framer Motion 的 `layout` 属性可以自动为布局变化添加动画：

```jsx
function LayoutAnimation() {
  const [expanded, setExpanded] = useState(false);
  
  return (
    <motion.div
      layout
      onClick={() => setExpanded(!expanded)}
      className={`bg-blue-500 rounded-lg cursor-pointer ${
        expanded ? "w-80 h-80" : "w-40 h-40"
      }`}
      transition={{ duration: 0.5, ease: "easeInOut" }}
    >
      <motion.h3 layout className="text-white p-4">
        点击我
      </motion.h3>
    </motion.div>
  );
}
```

### 共享布局动画

使用 `layoutId` 可以创建元素之间的共享动画：

```jsx
function SharedLayoutAnimation() {
  const [selected, setSelected] = useState(null);
  
  return (
    <div className="grid grid-cols-3 gap-4">
      {[1, 2, 3].map(id => (
        <motion.div
          key={id}
          layoutId={`card-${id}`}
          onClick={() => setSelected(id)}
          className="bg-blue-500 h-40 rounded-lg cursor-pointer"
        />
      ))}
      
      {selected && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
          <motion.div
            layoutId={`card-${selected}`}
            className="bg-blue-500 w-80 h-80 rounded-lg"
          >
            <motion.button
              onClick={() => setSelected(null)}
              className="mt-4 mx-4 px-4 py-2 bg-white rounded"
            >
              关闭
            </motion.button>
          </motion.div>
        </div>
      )}
    </div>
  );
}
```

## 动画存在

`AnimatePresence` 组件允许你为元素的进入和退出添加动画：

```jsx
import { motion, AnimatePresence } from "framer-motion";

function AnimatedModal({ isOpen, onClose }) {
  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center"
        >
          <motion.div
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: 50, opacity: 0 }}
            transition={{ type: "spring", damping: 20 }}
            className="bg-white p-6 rounded-lg w-full max-w-md"
          >
            <h2 className="text-xl font-bold mb-4">模态框标题</h2>
            <p className="mb-4">模态框内容</p>
            <button
              onClick={onClose}
              className="bg-blue-500 text-white px-4 py-2 rounded"
            >
              关闭
            </button>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

### 列表动画

```jsx
function AnimatedList({ items }) {
  return (
    <ul className="space-y-2">
      <AnimatePresence>
        {items.map(item => (
          <motion.li
            key={item.id}
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: "auto" }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="p-4 bg-gray-100 rounded"
          >
            {item.text}
          </motion.li>
        ))}
      </AnimatePresence>
    </ul>
  );
}
```

## 滚动动画

### 使用 useScroll

`useScroll` 钩子可以创建基于滚动位置的动画：

```jsx
import { motion, useScroll, useTransform } from "framer-motion";

function ScrollAnimation() {
  const { scrollYProgress } = useScroll();
  const scale = useTransform(scrollYProgress, [0, 1], [1, 2]);
  const opacity = useTransform(scrollYProgress, [0, 0.5, 1], [0.2, 1, 0.2]);
  
  return (
    <div className="h-[200vh] pt-[50vh]">
      <motion.div
        style={{ scale, opacity }}
        className="w-40 h-40 bg-blue-500 rounded-full mx-auto"
      />
    </div>
  );
}
```

### 视差效果

```jsx
function ParallaxSection() {
  const { scrollYProgress } = useScroll();
  const y1 = useTransform(scrollYProgress, [0, 1], [0, 200]);
  const y2 = useTransform(scrollYProgress, [0, 1], [0, -200]);
  
  return (
    <div className="h-[100vh] overflow-hidden relative">
      <motion.div
        style={{ y: y1 }}
        className="absolute inset-0 bg-blue-300"
      />
      <motion.div
        style={{ y: y2 }}
        className="absolute inset-0 bg-blue-500 opacity-50"
      />
      <div className="relative z-10 h-full flex items-center justify-center">
        <h1 className="text-4xl font-bold text-white">视差效果</h1>
      </div>
    </div>
  );
}
```

## SVG 动画

Framer Motion 提供了强大的 SVG 动画支持：

### 路径动画

```jsx
function PathAnimation() {
  const pathVariants = {
    hidden: {
      pathLength: 0,
      opacity: 0
    },
    visible: {
      pathLength: 1,
      opacity: 1,
      transition: {
        pathLength: { duration: 2, ease: "easeInOut" },
        opacity: { duration: 0.5 }
      }
    }
  };
  
  return (
    <motion.svg
      width="200"
      height="200"
      viewBox="0 0 100 100"
      initial="hidden"
      animate="visible"
    >
      <motion.path
        d="M10,50 C10,10 90,10 90,50 C90,90 10,90 10,50 Z"
        stroke="#3B82F6"
        strokeWidth="4"
        fill="none"
        variants={pathVariants}
      />
    </motion.svg>
  );
}
```

### 形状变形

```jsx
function MorphAnimation() {
  const [isCircle, setIsCircle] = useState(false);
  
  const pathVariants = {
    square: { d: "M10,10 L90,10 L90,90 L10,90 Z" },
    circle: { d: "M50,10 A40,40 0 1,1 50,90 A40,40 0 1,1 50,10 Z" }
  };
  
  return (
    <div>
      <motion.svg
        width="200"
        height="200"
        viewBox="0 0 100 100"
        onClick={() => setIsCircle(!isCircle)}
      >
        <motion.path
          fill="#3B82F6"
          variants={pathVariants}
          animate={isCircle ? "circle" : "square"}
          transition={{ duration: 0.5 }}
        />
      </motion.svg>
      <p className="text-center mt-4">点击切换形状</p>
    </div>
  );
}
```

## 高级技巧

### 1. 自定义组件

你可以使用 `motion` 函数创建自定义动画组件：

```jsx
import { motion } from "framer-motion";

// 为自定义 React 组件添加动画功能
const MotionComponent = motion(MyComponent);

// 使用
<MotionComponent animate={{ scale: 1.2 }} />;
```

### 2. 使用 MotionValues

`useMotionValue` 和 `useTransform` 可以创建动态值和转换：

```jsx
import { motion, useMotionValue, useTransform } from "framer-motion";

function DynamicValues() {
  const x = useMotionValue(0);
  const opacity = useTransform(x, [-100, 0, 100], [0, 1, 0]);
  const scale = useTransform(x, [-100, 0, 100], [0.5, 1, 1.5]);
  
  return (
    <motion.div
      drag="x"
      style={{ x, opacity, scale }}
      className="w-40 h-40 bg-purple-500 rounded-lg cursor-grab"
    >
      拖拽我
    </motion.div>
  );
}
```

### 3. 动画生命周期

使用 `onAnimationStart` 和 `onAnimationComplete` 监听动画事件：

```jsx
<motion.div
  animate={{ x: 100 }}
  onAnimationStart={() => console.log("动画开始")}
  onAnimationComplete={() => console.log("动画结束")}
/>
```

### 4. 可访问性考虑

尊重用户的减少动画设置：

```jsx
import { motion, useReducedMotion } from "framer-motion";

function AccessibleAnimation() {
  const shouldReduceMotion = useReducedMotion();
  
  const variants = {
    hidden: { opacity: 0, y: shouldReduceMotion ? 0 : 20 },
    visible: { opacity: 1, y: 0 }
  };
  
  return (
    <motion.div
      variants={variants}
      initial="hidden"
      animate="visible"
      transition={{ duration: shouldReduceMotion ? 0 : 0.5 }}
    >
      可访问的动画
    </motion.div>
  );
}
```

## 性能优化

### 1. 使用 `layout` 属性时的优化

当使用 `layout` 属性时，可以通过 `layoutId` 和 `layoutDependency` 优化性能：

```jsx
<motion.div
  layout
  layoutId="unique-id"
  layoutDependency={someValue}
/>
```

### 2. 避免不必要的重新渲染

使用 `useMotionValue` 可以避免不必要的重新渲染：

```jsx
function OptimizedAnimation() {
  const x = useMotionValue(0);
  
  // 这不会导致组件重新渲染
  function handleClick() {
    x.set(100);
  }
  
  return (
    <>
      <motion.div style={{ x }} className="w-20 h-20 bg-blue-500" />
      <button onClick={handleClick}>移动</button>
    </>
  );
}
```

### 3. 使用 `useDragControls`

对于复杂的拖拽交互，使用 `useDragControls` 可以提高性能：

```jsx
import { motion, useDragControls } from "framer-motion";

function DragWithControls() {
  const dragControls = useDragControls();
  
  function startDrag(event) {
    dragControls.start(event);
  }
  
  return (
    <div>
      <div
        onPointerDown={startDrag}
        className="w-20 h-10 bg-gray-300 mb-4 cursor-pointer"
      >
        拖动手柄
      </div>
      <motion.div
        drag="y"
        dragControls={dragControls}
        className="w-40 h-40 bg-blue-500"
      />
    </div>
  );
}
```

## 实用示例

### 1. 页面过渡

```jsx
import { motion, AnimatePresence } from "framer-motion";
import { useRouter } from "next/router";

function PageTransition({ children }) {
  const { asPath } = useRouter();
  
  const variants = {
    hidden: { opacity: 0, x: -200 },
    enter: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: 200 }
  };
  
  return (
    <div className="overflow-hidden">
      <AnimatePresence mode="wait">
        <motion.div
          key={asPath}
          variants={variants}
          initial="hidden"
          animate="enter"
          exit="exit"
          transition={{ duration: 0.3 }}
        >
          {children}
        </motion.div>
      </AnimatePresence>
    </div>
  );
}
```

### 2. 图片库

```jsx
function ImageGallery({ images }) {
  const [selectedId, setSelectedId] = useState(null);
  
  return (
    <div className="grid grid-cols-3 gap-4">
      {images.map(image => (
        <motion.div
          key={image.id}
          layoutId={`image-${image.id}`}
          onClick={() => setSelectedId(image.id)}
          className="cursor-pointer overflow-hidden rounded-lg"
          whileHover={{ scale: 1.05 }}
        >
          <motion.img
            src={image.src}
            alt={image.alt}
            className="w-full h-auto"
            layoutId={`image-img-${image.id}`}
          />
        </motion.div>
      ))}
      
      <AnimatePresence>
        {selectedId && (
          <motion.div
            className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedId(null)}
          >
            <motion.div
              layoutId={`image-${selectedId}`}
              className="max-w-3xl max-h-[80vh] overflow-hidden rounded-lg"
              onClick={e => e.stopPropagation()}
            >
              <motion.img
                src={images.find(img => img.id === selectedId).src}
                alt={images.find(img => img.id === selectedId).alt}
                layoutId={`image-img-${selectedId}`}
                className="w-full h-auto"
              />
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
```

### 3. 滚动进度指示器

```jsx
function ScrollProgressIndicator() {
  const { scrollYProgress } = useScroll();
  
  return (
    <motion.div
      className="fixed top-0 left-0 right-0 h-1 bg-blue-500 origin-left"
      style={{ scaleX: scrollYProgress }}
    />
  );
}
```

## 结论

Framer Motion 是一个强大而灵活的 React 动画库，它提供了从简单过渡到复杂交互的全方位动画解决方案。通过本文介绍的基础知识、高级技巧和实用示例，你可以掌握 Framer Motion 的核心功能，为你的 React 应用添加流畅、专业的动画效果。

记住，好的动画应该是有目的的，它们应该增强用户体验，而不是分散注意力。通过合理使用 Framer Motion，你可以创建出既美观又实用的动画效果，提升你的 React 应用的用户体验。

无论你是动画新手还是有经验的开发者，希望这篇完全指南能够帮助你更好地理解和应用 Framer Motion。
