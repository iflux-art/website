---
title: 代码规范
description: 项目代码编写规范和最佳实践
date: 2025-08-29
category: 开发指南
tags:
  - 代码规范
  - 最佳实践
  - TypeScript
---

# 代码规范

本文档详细说明斐流艺创项目的代码编写规范和最佳实践，确保代码质量和团队协作效率。

## TypeScript规范

### 1. 类型定义

#### 接口命名

使用PascalCase命名接口，推荐使用描述性名称：

```typescript
// 推荐
interface UserProfile {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

// 不推荐
interface user_profile {
  id: string;
  name: string;
  email: string;
  created_at: Date;
}
```

#### 类型别名

对于联合类型和原始类型，使用类型别名：

```typescript
// 基本类型别名
type UserId = string;
type Email = string;

// 联合类型
type Status = 'pending' | 'approved' | 'rejected';

// 复杂类型别名
type ApiResponse<T> = {
  success: boolean;
  data: T;
  message?: string;
  timestamp: string;
};
```

#### 泛型使用

合理使用泛型提高代码复用性：

```typescript
// 好的示例
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(data: Partial<T>): Promise<T>;
}

// 不好的示例
interface UserRepository {
  findById(id: string): Promise<any>;
  findAll(): Promise<any[]>;
  create(data: any): Promise<any>;
}
```

### 2. 函数规范

#### 函数声明

优先使用箭头函数和函数表达式：

```typescript
// 推荐：箭头函数
const getUserById = (id: string): Promise<User | null> => {
  // 实现
};

// 推荐：函数表达式
const calculateTotal = function(prices: number[]): number {
  return prices.reduce((sum, price) => sum + price, 0);
};

// 不推荐：函数声明（在模块中）
function processUserData(users: User[]): ProcessedUser[] {
  // 实现
}
```

#### 参数处理

使用解构和默认参数：

```typescript
// 好的示例
interface CreateUserOptions {
  name: string;
  email: string;
  age?: number;
  isActive?: boolean;
}

const createUser = ({
  name,
  email,
  age = 0,
  isActive = true
}: CreateUserOptions): User => {
  return {
    id: generateId(),
    name,
    email,
    age,
    isActive,
    createdAt: new Date()
  };
};

// 不好的示例
const createUser = (name: string, email: string, age: number, isActive: boolean): User => {
  // 实现
};
```

### 3. 类和对象

#### 类定义

使用class关键字定义类，并遵循单一职责原则：

```typescript
// 好的示例
class UserService {
  private userRepository: UserRepository;
  
  constructor(userRepository: UserRepository) {
    this.userRepository = userRepository;
  }
  
  async getUserById(id: string): Promise<User | null> {
    return this.userRepository.findById(id);
  }
  
  async createUser(userData: CreateUserDto): Promise<User> {
    const user = new User(userData);
    return this.userRepository.create(user);
  }
}

// 不好的示例
class UserManager {
  // 太多职责
  getUserById() { /* ... */ }
  createUser() { /* ... */ }
  sendEmail() { /* ... */ }
  generateReport() { /* ... */ }
}
```

#### 访问修饰符

明确指定访问修饰符：

```typescript
class BankAccount {
  private balance: number;
  protected accountNumber: string;
  public owner: string;
  
  constructor(owner: string, initialBalance: number) {
    this.owner = owner;
    this.balance = initialBalance;
    this.accountNumber = this.generateAccountNumber();
  }
  
  private generateAccountNumber(): string {
    // 生成账户号码
    return Math.random().toString(36).substring(2, 15);
  }
  
  public getBalance(): number {
    return this.balance;
  }
  
  public deposit(amount: number): void {
    if (amount > 0) {
      this.balance += amount;
    }
  }
  
  public withdraw(amount: number): boolean {
    if (amount > 0 && amount <= this.balance) {
      this.balance -= amount;
      return true;
    }
    return false;
  }
}
```

## React规范

### 1. 组件定义

#### 函数组件

优先使用函数组件和Hooks：

```typescript
// 推荐
interface UserCardProps {
  user: User;
  onEdit: (user: User) => void;
  onDelete: (userId: string) => void;
}

export const UserCard: React.FC<UserCardProps> = ({ 
  user, 
  onEdit, 
  onDelete 
}) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <div className="actions">
        <button onClick={() => onEdit(user)}>编辑</button>
        <button onClick={() => onDelete(user.id)}>删除</button>
      </div>
    </div>
  );
};
```

#### 组件状态

合理使用useState和useReducer：

```typescript
// 简单状态使用useState
const [count, setCount] = useState(0);

// 复杂状态使用useReducer
interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
}

type UserAction =
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: User[] }
  | { type: 'FETCH_ERROR'; payload: string };

const userReducer = (state: UserState, action: UserAction): UserState => {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, users: action.payload };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};

const [state, dispatch] = useReducer(userReducer, {
  users: [],
  loading: false,
  error: null
});
```

### 2. Hooks使用

#### 自定义Hooks

提取可复用逻辑到自定义Hooks：

```typescript
// src/hooks/use-api.ts
interface UseApiOptions<T> {
  url: string;
  initialValue: T;
}

interface UseApiResult<T> {
  data: T;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useApi<T>({ url, initialValue }: UseApiOptions<T>): UseApiResult<T> {
  const [data, setData] = useState<T>(initialValue);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [url]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { data, loading, error, refetch: fetchData };
}
```

#### Hooks规则

遵循React Hooks规则：

```typescript
// 正确：Hooks在顶层调用
function MyComponent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  useEffect(() => {
    // 副作用
  }, [count]);
  
  return (
    <div>
      <p>{count}</p>
      <p>{name}</p>
    </div>
  );
}

// 错误：在条件语句中调用Hooks
function MyComponent({ condition }: { condition: boolean }) {
  if (condition) {
    const [count, setCount] = useState(0); // 错误！
  }
  
  return <div>...</div>;
}
```

### 3. 组件组织

#### 组件文件结构

```tsx
// src/components/user-profile.tsx
import { useState } from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Avatar } from '@/components/ui/avatar';

// 类型定义
interface UserProfileProps {
  user: User;
  className?: string;
}

// 主组件
export function UserProfile({ user, className }: UserProfileProps) {
  const [isEditing, setIsEditing] = useState(false);
  
  return (
    <div className={cn('user-profile', className)}>
      <Avatar src={user.avatar} alt={user.name} />
      <div className="user-info">
        <h2>{user.name}</h2>
        <p>{user.email}</p>
      </div>
      <Button onClick={() => setIsEditing(true)}>编辑</Button>
    </div>
  );
}

// 子组件
function UserActions({ user }: { user: User }) {
  return (
    <div className="user-actions">
      <Button variant="secondary">消息</Button>
      <Button variant="secondary">关注</Button>
    </div>
  );
}
```

## 样式规范

### 1. Tailwind CSS使用

#### 类名组织

按照功能和视觉层次组织类名：

```tsx
// 好的示例
<button
  className={cn(
    'inline-flex items-center justify-center rounded-md font-medium transition-colors',
    'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',
    'disabled:pointer-events-none disabled:opacity-50',
    {
      'bg-primary text-primary-foreground hover:bg-primary/90': variant === 'primary',
      'bg-secondary text-secondary-foreground hover:bg-secondary/80': variant === 'secondary',
    },
    {
      'h-9 rounded-md px-3': size === 'sm',
      'h-10 py-2 px-4': size === 'md',
      'h-11 rounded-md px-8': size === 'lg',
    },
    className
  )}
>
  {children}
</button>
```

#### 响应式设计

合理使用响应式断点：

```tsx
<div className="container mx-auto px-4 sm:px-6 lg:px-8">
  <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
    {/* 内容 */}
  </div>
</div>
```

### 2. CSS模块

对于复杂样式，使用CSS模块：

```css
/* src/components/user-card.module.css */
.userCard {
  display: flex;
  flex-direction: column;
  padding: 1rem;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
  transition: box-shadow 0.2s ease-in-out;
}

.userCard:hover {
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.userCard header {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
}

.userCard .avatar {
  width: 3rem;
  height: 3rem;
  border-radius: 50%;
  margin-right: 1rem;
}

.userCard .name {
  font-size: 1.25rem;
  font-weight: 600;
}
```

```tsx
// src/components/user-card.tsx
import styles from './user-card.module.css';

export function UserCard({ user }: { user: User }) {
  return (
    <div className={styles.userCard}>
      <header>
        <img 
          src={user.avatar} 
          alt={user.name} 
          className={styles.avatar} 
        />
        <h2 className={styles.name}>{user.name}</h2>
      </header>
      <p>{user.email}</p>
    </div>
  );
}
```

## 代码组织

### 1. 目录结构

遵循功能驱动的目录结构：

```
src/
├── app/ - Next.js 应用路由
├── components/ - 共享UI组件
│   ├── ui/ - 基础UI组件
│   ├── layout/ - 布局组件
│   └── mdx/ - MDX渲染组件
├── features/ - 功能模块
│   ├── blog/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── lib/
│   │   ├── types/
│   │   └── index.ts
│   └── auth/
│       ├── components/
│       ├── hooks/
│       ├── lib/
│       ├── types/
│       └── index.ts
├── lib/ - 工具函数
├── hooks/ - 自定义Hooks
├── stores/ - 状态管理
├── types/ - 类型定义
└── utils/ - 工具函数
```

### 2. 模块导出

合理组织模块导出：

```typescript
// src/features/blog/index.ts
export * from './components';
export * from './hooks';
export * from './lib';
export * from './types';

// src/features/blog/components/index.ts
export * from './blog-card';
export * from './tag-cloud-card';
export * from './latest-posts-card';
```

### 3. 文件命名

使用一致的文件命名规范：

```bash
# 组件文件
user-profile.tsx
button.tsx
card.tsx

# 工具文件
utils.ts
helpers.ts
constants.ts

# 类型文件
types.ts
interfaces.ts
enums.ts
```

## 测试规范

### 1. 单元测试

使用Vitest编写单元测试：

```typescript
// src/lib/utils.test.ts
import { describe, it, expect } from 'vitest';
import { formatDate, slugify } from './utils';

describe('utils', () => {
  describe('formatDate', () => {
    it('should format date correctly', () => {
      const date = '2025-08-29';
      const formatted = formatDate(date);
      expect(formatted).toBe('2025年8月29日');
    });
    
    it('should handle invalid date', () => {
      const date = 'invalid-date';
      const formatted = formatDate(date);
      expect(formatted).toBe('Invalid Date');
    });
  });
  
  describe('slugify', () => {
    it('should convert string to slug', () => {
      const text = 'Hello World';
      const slug = slugify(text);
      expect(slug).toBe('hello-world');
    });
    
    it('should handle special characters', () => {
      const text = 'Hello, World!';
      const slug = slugify(text);
      expect(slug).toBe('hello-world');
    });
  });
});
```

### 2. 组件测试

使用React Testing Library测试组件：

```tsx
// src/components/button.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './button';

describe('Button', () => {
  it('should render correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
  
  it('should handle click events', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('should be disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByText('Click me')).toBeDisabled();
  });
});
```

## 文档规范

### 1. 代码注释

编写清晰的代码注释：

```typescript
/**
 * 格式化日期字符串
 * 
 * @param date - 日期字符串 (YYYY-MM-DD格式)
 * @returns 格式化后的日期字符串 (YYYY年M月D日格式)
 * 
 * @example
 * ```typescript
 * const formatted = formatDate('2025-08-29');
 * console.log(formatted); // "2025年8月29日"
 * ```
 */
export function formatDate(date: string): string {
  try {
    const [year, month, day] = date.split('-');
    return `${year}年${parseInt(month, 10)}月${parseInt(day, 10)}日`;
  } catch {
    return 'Invalid Date';
  }
}
```

### 2. 组件文档

为组件编写详细的文档：

```tsx
/**
 * 按钮组件
 * 
 * @description 一个可定制的按钮组件，支持多种样式和尺寸
 * 
 * @param {ButtonProps} props - 组件Props
 * @param {('primary'|'secondary'|'ghost')} [props.variant='primary'] - 按钮样式变体
 * @param {('sm'|'md'|'lg')} [props.size='md'] - 按钮尺寸
 * @param {boolean} [props.disabled=false] - 是否禁用
 * @param {Function} [props.onClick] - 点击事件处理函数
 * @param {React.ReactNode} props.children - 按钮内容
 * 
 * @example
 * ```tsx
 * <Button variant="primary" size="md" onClick={handleClick}>
 *   点击我
 * </Button>
 * ```
 */
```

通过遵循这些代码规范，我们可以确保项目代码的一致性、可读性和可维护性。